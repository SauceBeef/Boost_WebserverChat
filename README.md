### **架构方面**
#### 1. **项目整体架构**
- **前端（Web客户端）**：基于Node.js构建，负责用户界面展示和与后端的交互。
- **后端（服务端）**：基于C++编写，负责处理HTTP和WebSocket请求，与MySQL和Redis进行数据交互。
- **数据库**：
  - **MySQL**：存储用户信息（用户名、邮箱、密码等）。
  - **Redis**：存储聊天消息和用户会话信息（cookie等）。

#### 2. **Server端架构**
- **网络模型**：
  - 使用协程框架处理HTTP和WebSocket请求。
  - 可以基于Reactor网络模型重构HTTP和WebSocket服务，以提高性能和可维护性。
- **主要模块**：
  - **HTTP服务**：处理用户注册、登录等HTTP请求。
  - **WebSocket服务**：处理聊天消息的实时传输。
  - **MySQL客户端**：负责与MySQL数据库交互，存储和查询用户信息。
  - **Redis客户端**：负责与Redis交互，存储和查询聊天消息及用户会话信息。

#### 3. **数据存储**
- **MySQL**
- **Redis**：
  - **房间消息**：使用Redis的Stream结构存储，键为房间ID，值为聊天消息。
  - **用户会话**：使用Redis的String结构存储，键为cookie，值为用户ID，默认有效期为7天。

#### 4. **消息处理**
- **HTTP请求处理**：
  - 用户注册和登录通过HTTP API实现。
  - 服务端解析JSON格式的请求数据，与MySQL交互后返回响应结果。
- **WebSocket消息处理**：
  - 客户端连接后，发送`hello`类型的消息，服务端返回包含用户信息和房间信息的响应。
  - 聊天消息通过`clientMessages`类型发送，服务端处理后广播给房间内的其他用户，消息类型变为`serverMessages`。
  - 服务端将消息存储到Redis的Stream中，以便后续查询历史消息。

### **功能与拓展分析**
#### 1. **功能分析**
- **多房间聊天**：支持创建多个聊天房间，用户可以加入不同的房间进行聊天。
- **用户管理**：支持用户注册、登录，用户信息存储在MySQL中。
- **消息存储与查询**：聊天消息存储在Redis的Stream中，支持查询历史消息。
- **会话管理**：使用Redis存储用户会话信息（cookie），支持自动登录和会话过期机制。

#### 2. **可拓展性分析**
- **建议扩展功能**：
  - 基于Reactor模型重构网络服务，提高性能和可维护性。
  - 使用`rapidjson`优化JSON的序列化和反序列化。
  - 仿写MySQL/Redis连接池，提高数据库访问效率。
  - 增加房间创建、修改、删除接口，并将房间成员信息存储到MySQL。
  - 使用`gtest`替换现有单元测试框架，提高测试覆盖率和可靠性。


### **服务端具体模块分析**

#### **项目流程**：
1.**主事件循环**:
- 使用 boost::asio::io_context 创建一个事件循环 (ioc)，用于处理异步事件。
- 通过设置并发提示为 1 来确保服务器是单线程的。
2.**共享状态**:
- 创建一个 shared_state 对象 (st)，其中包含所有连接共享的单例对象。
- shared_state 包括文档根目录 (doc_root) 和 Redis 客户端。
3.**监听端点**:
- 使用 boost::asio::ip::tcp::endpoint 创建一个服务器监听的物理端点 (listening_endpoint)。
4.**信号处理**:
- 使用 boost::asio::signal_set 拦截 SIGINT 和 SIGTERM 信号，以实现优雅的退出。
5.**Redis 客户端**:
- 启动 Redis 连接 (st->redis().start_run())，用于处理与 Redis 的通信。
6.**HTTP 监听器**:
- 启动 HTTP 监听器 (launch_http_listener) 来处理传入的 HTTP 连接。

#### **模块分析**：
1.**主事件循环 (ioc.run())**:
- 事件循环会阻塞运行，直到上下文停止。所有的异步任务都会在此期间处理。
2.**共享状态 (shared_state)**:
- 提供一个共享的状态对象，包含了文档根目录和执行器，用于管理所有连接的共享资源。
- 包括一个 Redis 客户端，用于与 Redis 服务器进行通信。
3.**信号处理**:
- 通过 signals.async_wait 捕获 SIGINT 和 SIGTERM 信号，执行优雅的关闭操作，停止 Redis 重连循环和事件循环。
4.**HTTP 监听器**:
- 启动 HTTP 监听器来处理传入的 HTTP 请求，并将其路由到相应的处理程序。
- 错误处理和日志记录：如果启动 HTTP 监听器时发生错误，会记录错误并退出程序。
通过这些模块的协同工作，项目实现了一个高效、可扩展的 Web 服务器，能够处理 HTTP 请求并与 Redis 服务器进行通信。

